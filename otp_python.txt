12Apr24 Session
    // ./otp keygen -l N [-k key.txt | <stdout>]
    // e.g., ./otp -l 128 <enter> // dump a 128 char key to stdout->terminal
    // e.g., ./otp -l 128 > key.txt <enter> // dump a 128 char key to stdout->key.txt (shell)
    // e.g., ./otp -l 128 -k key.txt <enter> // dump a 128 char key to key.txt (NOT stdout)

    // cat pt.txt | ./otp encode -k key.txt | ./otp decode -k key.txt | diff pt.txt

    // ./otp -k key.txt pt.txt | ./otp encode -k key.txt | ./otp decode -k key.txt | diff pt.txt

    // print nothing


    python3 otp_python.py -l N -k key.txt 

    MUST STRING EVERYTHING TOGETHER
    - KEY + PLAINTEXT | ENCODE | DECODE | CAT 

19Apr24
// cat pt.txt | ./otp encode -k key.txt | ./otp decode -k key.txt | diff pt.txt
- encode's source for PT:
1. stdin (as above)
2. pt.txt -> './otp encode -i pt.txt -k key.txt | ./otp decode -k key.txt | diff pt.txt`
3. "command line PT" -> './otp encode -p "command line PT" -k key.txt | ./otp decode -k key.txt | diff pt.txt`

// ./otp keygen -seed s -l N [-k key.txt | <stdout>]    // implicitly ALPHABET
func keygen(seed, length, ALPHABET) -> key: str
- if seed, length and ALPHA are same - keygen will always generate the same key

./otp encode -p "plain text" -seed -length | ./otp decode -seed -length | diff pt.txt`
./otp  keygen -k key.txt -seed -length |./otp encode -p "plain text" -seed -length | ./otp decode -seed -length | diff pt.txt`

// ./otp keygen -seed s -l N > mykey.key


4/23
- think aobut how to exten split encode/decode into client (cml parsing and packgaing to server) and server(processing, encoding and decoeing) side
- 

# input-file-name = None
# if the input-file-arg is supplied - -i foo.txt
#   input-file-name = foo.txt
# else if input-file-arg is missing - -i
#   input-file-name = pt.txt
#
# "named file"
# if input-file-name is not None    # in this instance,
# it is either foo.txt or pt.txt
#   fs = open(input-file-name)
# else  # input-file-name is None
#   fs = stdin
#
### all refs. to the input file (stream) is through 'fs'
# all readfs / writes use fs - in out case just read
# os.read(fs)


7/15
typedef struct {
    int keylen;
    char key[]; #can't; compiler doesn't know how much mem is necessary
    int ptlen;
    char plaintext[];
}

header
- houses all the metadata
typedef struct {
    int keylen;
    int ptlen;
}

- look at webserver; header predefined as a http header